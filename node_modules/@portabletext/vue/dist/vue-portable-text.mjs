import { h as k, defineComponent as W, openBlock as F, createBlock as H } from "vue";
function P(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(c) {
      return Object.getOwnPropertyDescriptor(e, c).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function D(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P(Object(n), !0).forEach(function(r) {
      q(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function q(e, t, n) {
  return t = R(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function R(e) {
  var t = z(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function z(e, t) {
  if (typeof e != "object" || e === null)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function x(e) {
  return e._type === "span" && "text" in e && typeof e.text == "string" && (typeof e.marks > "u" || Array.isArray(e.marks) && e.marks.every((t) => typeof t == "string"));
}
function S(e) {
  return (
    // A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof e._type == "string" && // Toolkit-types like nested spans are @-prefixed
    e._type[0] !== "@" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    (!("markDefs" in e) || !e.markDefs || Array.isArray(e.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    e.markDefs.every((t) => typeof t._key == "string")) && // `children` is required and needs to be an array
    "children" in e && Array.isArray(e.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    e.children.every((t) => typeof t == "object" && "_type" in t)
  );
}
function A(e) {
  return S(e) && "listItem" in e && typeof e.listItem == "string" && (typeof e.level > "u" || typeof e.level == "number");
}
function E(e) {
  return e._type === "@list";
}
function N(e) {
  return e._type === "@span";
}
function U(e) {
  return e._type === "@text";
}
const B = ["strong", "em", "code", "underline", "strike-through"];
function V(e, t, n) {
  if (!x(e) || !e.marks)
    return [];
  if (!e.marks.length)
    return [];
  const r = e.marks.slice(), c = {};
  return r.forEach((i) => {
    c[i] = 1;
    for (let s = t + 1; s < n.length; s++) {
      const f = n[s];
      if (f && x(f) && Array.isArray(f.marks) && f.marks.indexOf(i) !== -1)
        c[i]++;
      else
        break;
    }
  }), r.sort((i, s) => G(c, i, s));
}
function G(e, t, n) {
  const r = e[t], c = e[n];
  if (r !== c)
    return c - r;
  const i = B.indexOf(t), s = B.indexOf(n);
  return i !== s ? i - s : t.localeCompare(n);
}
function J(e) {
  var t;
  const {
    children: n,
    markDefs: r = []
  } = e;
  if (!n || !n.length)
    return [];
  const c = n.map(V), i = {
    _type: "@span",
    children: [],
    markType: "<unknown>"
  };
  let s = [i];
  for (let f = 0; f < n.length; f++) {
    const d = n[f];
    if (!d)
      continue;
    const w = c[f] || [];
    let _ = 1;
    if (s.length > 1)
      for (_; _ < s.length; _++) {
        const o = ((t = s[_]) == null ? void 0 : t.markKey) || "", u = w.indexOf(o);
        if (u === -1)
          break;
        w.splice(u, 1);
      }
    s = s.slice(0, _);
    let l = s[s.length - 1];
    if (l) {
      for (const o of w) {
        const u = r.find((m) => m._key === o), p = u ? u._type : o, a = {
          _type: "@span",
          _key: d._key,
          children: [],
          markDef: u,
          markType: p,
          markKey: o
        };
        l.children.push(a), s.push(a), l = a;
      }
      if (x(d)) {
        const o = d.text.split(`
`);
        for (let u = o.length; u-- > 1; )
          o.splice(u, 0, `
`);
        l.children = l.children.concat(o.map((u) => ({
          _type: "@text",
          text: u
        })));
      } else
        l.children = l.children.concat(d);
    }
  }
  return i.children;
}
function Q(e, t) {
  const n = [];
  let r;
  for (let c = 0; c < e.length; c++) {
    const i = e[c];
    if (i) {
      if (!A(i)) {
        n.push(i), r = void 0;
        continue;
      }
      if (!r) {
        r = O(i, c, t), n.push(r);
        continue;
      }
      if (X(i, r)) {
        r.children.push(i);
        continue;
      }
      if ((i.level || 1) > r.level) {
        const s = O(i, c, t);
        if (t === "html") {
          const f = r.children[r.children.length - 1], d = D(D({}, f), {}, {
            children: [...f.children, s]
          });
          r.children[r.children.length - 1] = d;
        } else
          r.children.push(s);
        r = s;
        continue;
      }
      if ((i.level || 1) < r.level) {
        const s = n[n.length - 1], f = s && L(s, i);
        if (f) {
          r = f, r.children.push(i);
          continue;
        }
        r = O(i, c, t), n.push(r);
        continue;
      }
      if (i.listItem !== r.listItem) {
        const s = n[n.length - 1], f = s && L(s, {
          level: i.level || 1
        });
        if (f && f.listItem === i.listItem) {
          r = f, r.children.push(i);
          continue;
        } else {
          r = O(i, c, t), n.push(r);
          continue;
        }
      }
      console.warn("Unknown state encountered for block", i), n.push(i);
    }
  }
  return n;
}
function X(e, t) {
  return (e.level || 1) === t.level && e.listItem === t.listItem;
}
function O(e, t, n) {
  return {
    _type: "@list",
    _key: "".concat(e._key || "".concat(t), "-parent"),
    mode: n,
    level: e.level || 1,
    listItem: e.listItem,
    children: [e]
  };
}
function L(e, t) {
  const n = t.level || 1, r = t.listItem || "normal", c = typeof t.listItem == "string";
  if (E(e) && (e.level || 1) === n && c && (e.listItem || "normal") === r)
    return e;
  if (!("children" in e))
    return;
  const i = e.children[e.children.length - 1];
  return i && !x(i) ? L(i, t) : void 0;
}
const Y = /^\s/, Z = /^\s/;
function we(e) {
  const t = Array.isArray(e) ? e : [e];
  let n = "";
  return t.forEach((r, c) => {
    if (!S(r))
      return;
    let i = !1;
    r.children.forEach((s) => {
      x(s) ? (n += i && n && !Z.test(n) && !Y.test(s.text) ? " " : "", n += s.text, i = !1) : i = !0;
    }), c !== t.length - 1 && (n += `

`);
  }), n;
}
function K(e) {
  let t = "";
  return e.children.forEach((n) => {
    U(n) ? t += n.text : N(n) && (t += K(n));
  }), t;
}
const ee = "html";
function te(e, t) {
  const { block: n, list: r, listItem: c, marks: i, types: s, ...f } = t;
  return {
    ...e,
    block: v(e, t, "block"),
    list: v(e, t, "list"),
    listItem: v(e, t, "listItem"),
    marks: v(e, t, "marks"),
    types: v(e, t, "types"),
    ...f
  };
}
function v(e, t, n) {
  const r = t[n], c = e[n];
  return typeof r == "function" || r && typeof c == "function" ? r : r ? {
    ...c,
    ...r
  } : c;
}
const y = (e) => (t, { slots: n }) => {
  var r;
  return k(e, (r = n.default) == null ? void 0 : r.call(n));
}, ne = ({ value: e }, { slots: t }) => {
  var n;
  return k("a", { href: e == null ? void 0 : e.href }, (n = t.default) == null ? void 0 : n.call(t));
}, re = { textDecoration: "underline" }, ie = {
  code: y("code"),
  em: y("em"),
  link: ne,
  "strike-through": y("del"),
  strong: y("strong"),
  underline: (e, { slots: t }) => {
    var n;
    return k("span", { style: re }, (n = t.default) == null ? void 0 : n.call(t));
  }
}, le = {
  number: y("ol"),
  bullet: y("ul")
}, oe = y("li"), T = (e, t) => `[@portabletext/vue] Unknown ${e}, specify a component for it in the \`components.${t}\` prop`, C = (e) => T(`block type "${e}"`, "types"), se = (e) => T(`mark type "${e}"`, "marks"), ce = (e) => T(`block style "${e}"`, "block"), ue = (e) => T(`list style "${e}"`, "list"), ae = (e) => T(`list item style "${e}"`, "listItem");
function fe(e) {
  console.warn(e);
}
const M = { display: "none" }, ye = ({
  value: e,
  isInline: t
}) => {
  const n = C(e._type);
  return t ? k("span", { style: M }, n) : k("div", { style: M }, n);
}, pe = ({ markType: e }, { slots: t }) => {
  var n;
  return k("span", { class: `unknown__pt__mark__${e}` }, (n = t.default) == null ? void 0 : n.call(t));
}, ke = y("p"), he = y("ul"), de = y("li"), me = () => k("br"), ge = {
  normal: y("p"),
  blockquote: y("blockquote"),
  h1: y("h1"),
  h2: y("h2"),
  h3: y("h3"),
  h4: y("h4"),
  h5: y("h5"),
  h6: y("h6")
}, $ = {
  types: {},
  block: ge,
  marks: ie,
  list: le,
  listItem: oe,
  hardBreak: me,
  unknownType: ye,
  unknownMark: pe,
  unknownList: he,
  unknownListItem: de,
  unknownBlockStyle: ke
}, Ie = (e, t = !1) => (n) => {
  if (t) {
    const { value: r, ...c } = n;
    return k(e, { ...c, ...r });
  }
  return k(e, { ...n.value });
}, _e = (e, t) => {
  function n(l) {
    const { node: o, index: u, isInline: p } = l, a = o._key || `node-${u}`;
    return E(o) ? i(o, u, a) : A(o) ? c(o, u, a) : N(o) ? s(o, u, a) : r(o) ? _(o, u, a, p) : S(o) ? f(o, u, a, p) : U(o) ? d(o, a) : w(o, u, a, p);
  }
  function r(l) {
    return l._type in e.types;
  }
  function c(l, o, u) {
    const p = j({ node: l, index: o, isInline: !1, renderNode: n }), a = e.listItem, g = (typeof a == "function" ? a : a[l.listItem]) || e.unknownListItem;
    if (g === e.unknownListItem) {
      const b = l.listItem || "bullet";
      t(ae(b), {
        type: b,
        nodeType: "listItemStyle"
      });
    }
    let h = p.children;
    if (l.style && l.style !== "normal") {
      const { listItem: b, ...I } = l;
      h = n({
        node: I,
        index: o,
        isInline: !1,
        renderNode: n
      });
    }
    return k(
      g,
      {
        key: u,
        value: l,
        index: o,
        isInline: !1,
        renderNode: n
      },
      () => h
    );
  }
  function i(l, o, u) {
    const p = l.children.map(
      (h, b) => n({
        node: h._key ? h : { ...h, _key: `li-${o}-${b}` },
        index: b,
        isInline: !1,
        renderNode: n
      })
    ), a = e.list, g = (typeof a == "function" ? a : a[l.listItem]) || e.unknownList;
    if (g === e.unknownList) {
      const h = l.listItem || "bullet";
      t(ue(h), {
        nodeType: "listStyle",
        type: h
      });
    }
    return k(
      g,
      {
        key: u,
        value: l,
        index: o,
        isInline: !1,
        renderNode: n
      },
      () => p
    );
  }
  function s(l, o, u) {
    const { markDef: p, markType: a, markKey: m } = l, g = e.marks[a] || e.unknownMark, h = l.children.map(
      (b, I) => n({ node: b, index: I, isInline: !0, renderNode: n })
    );
    return g === e.unknownMark && t(se(a), {
      nodeType: "mark",
      type: a
    }), k(
      g,
      {
        key: u,
        text: K(l),
        value: p,
        markType: a,
        markKey: m,
        renderNode: n
      },
      () => h
    );
  }
  function f(l, o, u, p) {
    const { _key: a, children: m, ...g } = j({
      node: l,
      index: o,
      isInline: p,
      renderNode: n
    }), h = g.node.style || "normal", I = (typeof e.block == "function" ? e.block : e.block[h]) || e.unknownBlockStyle;
    return I === e.unknownBlockStyle && t(ce(h), {
      nodeType: "blockStyle",
      type: h
    }), k(I, { key: u, ...g, value: g.node, renderNode: n }, () => m);
  }
  function d(l, o) {
    if (l.text === `
`) {
      const u = e.hardBreak;
      return u ? k(u, { key: o }) : `
`;
    }
    return l.text;
  }
  function w(l, o, u, p) {
    const a = {
      value: l,
      isInline: p,
      index: o,
      renderNode: n
    };
    t(C(l._type), {
      nodeType: "block",
      type: l._type
    });
    const m = e.unknownType;
    return k(m, { key: u, ...a });
  }
  function _(l, o, u, p) {
    const a = {
      value: l,
      isInline: p,
      index: o,
      renderNode: n
    }, m = e.types[l._type];
    return m ? k(m, { key: u, ...a }) : void 0;
  }
  return n;
};
function j(e) {
  const { node: t, index: n, isInline: r, renderNode: c } = e, s = J(t).map(
    (f, d) => c({ node: f, isInline: !0, index: d, renderNode: c })
  );
  return {
    _key: t._key || `block-${n}`,
    children: s,
    index: n,
    isInline: r,
    node: t
  };
}
const ve = /* @__PURE__ */ W({
  __name: "vue-portable-text",
  props: {
    value: {},
    components: {},
    onMissingComponent: { type: [Function, Boolean], default: () => fe },
    listNestingMode: {}
  },
  setup(e) {
    const t = e;
    function n() {
    }
    const r = t.onMissingComponent || n, c = Array.isArray(t.value) ? t.value : [t.value], i = Q(c, t.listNestingMode || ee), s = t.components ? te($, t.components) : $, f = _e(s, r), d = i.map(
      (_, l) => f({ node: _, index: l, isInline: !1, renderNode: f })
    ), w = () => d;
    return (_, l) => (F(), H(w));
  }
});
export {
  ve as PortableText,
  $ as defaultComponents,
  Ie as flattenProps,
  te as mergeComponents,
  we as toPlainText
};
